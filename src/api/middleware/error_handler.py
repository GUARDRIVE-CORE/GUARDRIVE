ol("adapter");var z;let F=class T extends P{constructor(e){super(e);g(this,z);this[u]=e}async getDirectoryHandle(e,r={}){if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");r.create=!!r.create;const n=await this[u].getDirectoryHandle(e,r);return new T(n)}async*entries(){const{FileSystemFileHandle:e}=await d(async()=>{const{FileSystemFileHandle:r}=await Promise.resolve().then(()=>_);return{FileSystemFileHandle:r}},void 0,import.meta.url);for await(const[r,n]of this[u].entries())yield[n.name,n.kind==="file"?new e(n):new T(n)]}async*getEntries(){const{FileSystemFileHandle:e}=await d(async()=>{const{FileSystemFileHandle:r}=await Promise.resolve().then(()=>_);return{FileSystemFileHandle:r}},void 0,import.meta.url);console.warn("deprecated, use .entries() instead");for await(let r of this[u].entries())yield r.kind==="file"?new e(r):new T(r)}async getFileHandle(e,r={}){const{FileSystemFileHandle:n}=await d(async()=>{const{FileSystemFileHandle:s}=await Promise.resolve().then(()=>_);return{FileSystemFileHandle:s}},void 0,import.meta.url);if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");r.create=!!r.create;const o=await this[u].getFileHandle(e,r);return new n(o)}async removeEntry(e,r={}){if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");return r.recursive=!!r.recursive,this[u].removeEntry(e,r)}async resolve(e){if(await e.isSameEntry(this))return[];const r=[{handle:this,path:[]}];for